{"version":3,"file":"index.umd.min.js","sources":["../src/index.ts"],"sourcesContent":["type SortablePrimitive = number | boolean | string | bigint | undefined | null;\ntype SortableObject = Date;\ntype SortableValue = SortablePrimitive | SortableObject;\n\ntype ComparatorOptions = {\n    defaultString?: string;\n    defaultNumber?: number;\n    transform?: (value: SortableValue) => SortableValue;\n    locale?: string;\n    collator?: Collator;\n};\n\ntype SortConfig<Type extends object> = {\n    [Path in SortablePath<Type>]: {\n        path: Path;\n        direction?: 'asc' | 'desc' | -1 | 1;\n        transform?: (value: TypeAtPath<Type, Path>) => SortableValue;\n    } & Omit<ComparatorOptions, 'transform'>;\n}[SortablePath<Type>];\n\ntype Sort<Type extends object> = SortConfig<Type> | SortPath<Type>;\n\nexport function createSortFn<Type extends object>(\n    ...params: [Sort<Type>, ...Sort<Type>[], ComparatorOptions]\n): (a: Type, b: Type) => number;\nexport function createSortFn<Type extends object>(\n    ...params: [Sort<Type>, ...Sort<Type>[]]\n): (a: Type, b: Type) => number;\nexport function createSortFn<Type extends object>(\n    ...params: (Sort<Type> | ComparatorOptions)[]\n): (a: Type, b: Type) => number {\n    const defaultLocale = 'en-u-co-eor-kn';\n\n    let options = params[params.length - 1];\n\n    if (!options || !isComparatorOptions(options)) {\n        options = {};\n    }\n\n    if (!options.collator) {\n        options.collator = new Intl.Collator(options.locale ?? defaultLocale);\n    }\n\n    const comparators: Comparator<Type>[] = [];\n\n    for (const param of params) {\n        if (isSortPath(param)) {\n            comparators.push({\n                dir: isAscPath(param) ? 1 : -1,\n                path: isAscPath(param)\n                    ? param\n                    : (param.substring(1) as AscPath<Type>),\n                ...(options as typeof options & { collator: Collator }),\n            });\n        }\n\n        if (isSortConfig(param)) {\n            if (param.locale && !param.collator) {\n                param.collator = new Intl.Collator(param.locale);\n            }\n\n            comparators.push({\n                dir:\n                    param.direction === 'desc' || param.direction === -1\n                        ? -1\n                        : 1,\n                ...(options as typeof options & { collator: Collator }),\n                ...param,\n            });\n        }\n    }\n\n    return (aObject, bObject) => {\n        for (const comparator of comparators) {\n            const {\n                dir,\n                path,\n                collator,\n                defaultNumber,\n                defaultString,\n                transform,\n            } = comparator;\n\n            let a = getByPath(aObject, path);\n            let b = getByPath(bObject, path);\n\n            if (transform) {\n                a = transform(a);\n                b = transform(b);\n            }\n\n            if (a === null) a = undefined;\n            if (b === null) b = undefined;\n\n            if (Object.is(a, b)) continue;\n\n            if (\n                typeof a !== typeof b &&\n                a instanceof Date !== b instanceof Date &&\n                a !== undefined &&\n                b !== undefined\n            ) {\n                throw new Error(`Cannot compare ${typeof a} and ${typeof b}`);\n            }\n\n            const type = a ? typeof a : typeof b;\n\n            if (type === 'number') {\n                a = a ?? defaultNumber;\n                b = b ?? defaultNumber;\n            }\n\n            if (type === 'string') {\n                a = a ?? defaultString;\n                b = b ?? defaultString;\n            }\n\n            if (a === undefined) return dir;\n            if (b === undefined) return -dir;\n\n            if (\n                (typeof a === 'number' && typeof b === 'number') ||\n                (typeof a === 'bigint' && typeof b === 'bigint') ||\n                (a instanceof Date && b instanceof Date)\n            ) {\n                if (Number.isNaN(a)) return dir;\n                if (Number.isNaN(b)) return -dir;\n\n                if (a > b) return dir;\n                if (a < b) return -dir;\n\n                continue;\n            }\n\n            if (typeof a === 'string' && typeof b === 'string') {\n                const compareResult = collator.compare(a, b);\n                if (compareResult) return dir * compareResult;\n\n                continue;\n            }\n\n            if (typeof a === 'boolean' && typeof b === 'boolean') {\n                return a ? dir : -dir;\n            }\n        }\n\n        return 0;\n    };\n}\n\ntype NoSpecialChars<Key extends string | undefined> = Key extends `-${string}`\n    ? never\n    : `${Key}`;\n\ntype Path<Object, Leaf, Index extends string = string> = Object extends object\n    ? {\n          [Key in keyof Object]: Key extends Index\n              ? Object[Key] extends Leaf\n                  ? NoSpecialChars<Key>\n                  : Object[Key] extends unknown[]\n                    ? `${Key}.${Path<Object[Key], Leaf, TupleKeys<Object[Key]>> | 'length'}`\n                    : Object[Key] extends object\n                      ? `${Key}.${Path<Object[Key], Leaf>}`\n                      : never\n              : never;\n      }[keyof Object & Index]\n    : never;\n\ntype TupleKeys<T extends unknown[]> = Exclude<keyof T, keyof unknown[]> &\n    string;\n\ntype TypeAtPath<\n    Object,\n    Path extends string,\n> = Path extends `${infer Key}.${infer Rest}`\n    ? Key extends keyof Object\n        ? TypeAtPath<Object[Key], Rest>\n        : never\n    : Path extends keyof Object\n      ? Object[Path]\n      : never;\n\ntype SortablePath<Type> = Path<Type, SortableValue>;\n\ntype AscPath<Type> = SortablePath<Type>;\ntype DescPath<Type> = `-${SortablePath<Type>}`;\ntype SortPath<Type> = AscPath<Type> | DescPath<Type>;\n\nfunction isAscPath<Type>(sortPath: SortPath<Type>): sortPath is AscPath<Type> {\n    return !sortPath.startsWith('-');\n}\n\nfunction isSortPath<Type extends object>(\n    sort: Sort<Type> | ComparatorOptions\n): sort is SortPath<Type> {\n    return typeof sort === 'string';\n}\n\nfunction isSortConfig<Type extends object>(\n    sort: Sort<Type> | ComparatorOptions\n): sort is SortConfig<Type> {\n    return typeof sort === 'object' && 'path' in sort;\n}\n\nfunction isComparatorOptions<Type extends object>(\n    sort: Sort<Type> | ComparatorOptions\n): sort is ComparatorOptions {\n    return typeof sort === 'object' && !('path' in sort);\n}\n\ntype Collator = { compare: (x: string, y: string) => number };\ntype Comparator<Type extends object> = {\n    dir: 1 | -1;\n    path: SortablePath<Type>;\n    collator: Collator;\n} & ComparatorOptions;\n\nfunction getByPath<Type extends object>(obj: Type, path: SortablePath<Type>) {\n    const parts = path.split('.');\n\n    let result: unknown = obj;\n\n    for (const part of parts) {\n        if (typeof result !== 'object' || result === null) {\n            throw new Error(`Invalid path: ${path}`);\n        }\n\n        result = result[part as keyof object];\n    }\n\n    return result as SortableValue;\n}\n"],"names":["isAscPath","sortPath","startsWith","isSortPath","sort","isSortConfig","getByPath","obj","path","parts","split","result","part","Error","params","options","length","collator","Intl","Collator","locale","comparators","param","push","dir","substring","direction","aObject","bObject","comparator","defaultNumber","defaultString","transform","a","b","undefined","Object","is","Date","type","Number","isNaN","compareResult","compare"],"mappings":";;;;;mPA4LA,SAASA,EAAgBC,GACrB,OAAQA,EAASC,WAAW,IAChC,CAEA,SAASC,EACLC,GAEA,MAAuB,iBAATA,CAClB,CAEA,SAASC,EACLD,GAEA,MAAuB,iBAATA,GAAqB,SAAUA,CACjD,CAeA,SAASE,EAA+BC,EAAWC,GAC/C,MAAMC,EAAQD,EAAKE,MAAM,KAEzB,IAAIC,EAAkBJ,EAEtB,IAAK,MAAMK,KAAQH,EAAO,CACtB,GAAsB,iBAAXE,GAAkC,OAAXA,EAC9B,MAAM,IAAIE,MAAM,iBAAiBL,KAGrCG,EAASA,EAAOC,EACnB,CAED,OAAOD,CACX,gBA3MgB,YACTG,GAIH,IAAIC,EAAUD,EAAOA,EAAOE,OAAS,GA2KzC,IACIZ,EA1KKW,IA4KkB,iBAFvBX,EA1KqCW,MA4KA,SAAUX,MA3K3CW,EAAU,CAAA,GAGTA,EAAQE,WACTF,EAAQE,SAAW,IAAIC,KAAKC,SAASJ,EAAQK,QAT3B,mBAYtB,MAAMC,EAAkC,GAExC,IAAK,MAAMC,KAASR,EACZX,EAAWmB,IACXD,EAAYE,KAAK,CACbC,IAAKxB,EAAUsB,GAAS,GAAK,EAC7Bd,KAAMR,EAAUsB,GACVA,EACCA,EAAMG,UAAU,MACnBV,IAIRV,EAAaiB,KACTA,EAAMF,SAAWE,EAAML,WACvBK,EAAML,SAAW,IAAIC,KAAKC,SAASG,EAAMF,SAG7CC,EAAYE,KAAK,CACbC,IACwB,SAApBF,EAAMI,YAA6C,IAArBJ,EAAMI,WAC7B,EACD,KACNX,KACDO,KAKf,MAAO,CAACK,EAASC,KACb,IAAK,MAAMC,KAAcR,EAAa,CAClC,MAAMG,IACFA,EAAGhB,KACHA,EAAIS,SACJA,EAAQa,cACRA,EAAaC,cACbA,EAAaC,UACbA,GACAH,EAEJ,IAAII,EAAI3B,EAAUqB,EAASnB,GACvB0B,EAAI5B,EAAUsB,EAASpB,GAU3B,GARIwB,IACAC,EAAID,EAAUC,GACdC,EAAIF,EAAUE,IAGR,OAAND,IAAYA,OAAIE,GACV,OAAND,IAAYA,OAAIC,GAEhBC,OAAOC,GAAGJ,EAAGC,GAAI,SAErB,UACWD,UAAaC,GACpBD,aAAaK,MAASJ,aAAaI,WAC7BH,IAANF,QACME,IAAND,EAEA,MAAM,IAAIrB,MAAM,yBAAyBoB,gBAAgBC,KAG7D,MAAMK,EAAON,SAAWA,SAAWC,EAYnC,GAVa,WAATK,IACAN,EAAIA,GAAKH,EACTI,EAAIA,GAAKJ,GAGA,WAATS,IACAN,EAAIA,GAAKF,EACTG,EAAIA,GAAKH,QAGHI,IAANF,EAAiB,OAAOT,EAC5B,QAAUW,IAAND,EAAiB,OAAQV,EAE7B,GACkB,iBAANS,GAA+B,iBAANC,GACnB,iBAAND,GAA+B,iBAANC,GAChCD,aAAaK,MAAQJ,aAAaI,KAHvC,CAKI,GAAIE,OAAOC,MAAMR,GAAI,OAAOT,EAC5B,GAAIgB,OAAOC,MAAMP,GAAI,OAAQV,EAE7B,GAAIS,EAAIC,EAAG,OAAOV,EAClB,GAAIS,EAAIC,EAAG,OAAQV,CAGtB,MAED,GAAiB,iBAANS,GAA+B,iBAANC,GAOpC,GAAiB,kBAAND,GAAgC,kBAANC,EACjC,OAAOD,EAAIT,GAAOA,MARtB,CACI,MAAMkB,EAAgBzB,EAAS0B,QAAQV,EAAGC,GAC1C,GAAIQ,EAAe,OAAOlB,EAAMkB,CAGnC,CAKJ,CAED,OAAO,CAAC,CAEhB"}